{
  "layer_1": {

    "n1_comment": "filter count for 1st layer",
    "n1": 3,

    "f1_comment": "spatial size",
    "f1": 3,

    "input_w": 5,
    "input_h": 5,
    "input": [
      0.0,     1.0,     0.81205, 0.85311, 0.43704,
      0.16959, 0.701,   0.413,   0.886,   0.78658,
      0.42971, 0.299,   0.587,   0.114,   0.70724,
      0.67016, 0.74524, 0.85311, 0.74524, 0.29913,
      0.8062,  0.58765, 0.8585,  0.5927,  0.70196],

    "weights_comment": "weights for 1st layer. (each column for different filter, each row for different pixel in range 0 - f1^2, so each paragraph is 1 row of pixels in f1=3)",
    "weights": [
      1.0, 0.0, 0.0,
      0.0, 1.0, 0.0,
      1.0, 0.0, 0.0,

      0.0, 1.0, 0.0,
      1.0, 0.0, 1.0,
      0.0, 1.0, 0.0,

      1.0, 0.0, 0.0,
      0.0, 1.0, 0.0,
      1.0, 0.0, 0.0
    ],

    "bias_comment": "biases for 1st layer",
    "bias": [0.1, 0.2, 0.3]
  },



  "layer_2": {

    "data_set_1": {
      "n2_comment": "filter count for 2nd layer",
      "n2": 2,

      "f2_comment": "spatial size",
      "f2": 3,

      "input": [
        0.406, 0.419, 0.598,
        0.442, 0.685, 0.528,
        0.627, 0.489, 0.642,
        0.376, 0.563, 0.499,
        0.680, 0.371, 0.571,
        0.390, 0.672, 0.453,
        0.626, 0.550, 0.609,
        0.386, 0.674, 0.634,
        0.666, 0.413, 0.609],

        "output": [16.3343, 31.0135],

        "weights_comment": "weights for second layer ((f2*f2*n1)*n2 dimensional) in other words each of n2 filters have a f2*f2*n1 cube of weights (each column for different filter, each row for different pixel in range 0 - f2*f2*n1, so each paragraph is cell, 9 cells total)",
        "weights": [
            1.000, 2.000,
            1.001, 2.001,
            1.002, 2.002,

            1.010, 2.010,
            1.011, 2.011,
            1.012, 2.012,

            1.020, 2.020,
            1.021, 2.021,
            1.022, 2.022,


            1.100, 2.100,
            1.101, 2.101,
            1.102, 2.102,

            1.110, 2.110,
            1.111, 2.111,
            1.112, 2.112,

            1.120, 2.120,
            1.121, 2.121,
            1.122, 2.122,


            1.200, 2.200,
            1.201, 2.201,
            1.202, 2.202,

            1.210, 2.210,
            1.211, 2.211,
            1.212, 2.212,

            1.220, 2.220,
            1.221, 2.221,
            1.222, 2.222],

        "bias_comment": "biases for 2nd layer (n2 dimensional)",
        "bias": [0.1, 0.2]
    },

    "data_set_2": {
      "n2_comment": "filter count for 2nd layer",
      "n2": 3,

      "f2_comment": "spatial size",
      "f2": 1,

      "input": [
        0.406, 0.419, 0.598,
        0.442, 0.685, 0.528,
        0.627, 0.489, 0.642,
        0.376, 0.563, 0.499,
        0.680, 0.371, 0.571,
        0.390, 0.672, 0.453,
        0.626, 0.550, 0.609,
        0.386, 0.674, 0.634,
        0.666, 0.413, 0.609],

      "output": [
        1.948, 2.634, 2.150,
        2.446, 2.832, 2.648,
        2.354, 3.234, 2.556,
        2.107, 2.519, 2.308,
        2.099, 3.079, 2.301,
        2.292, 2.564, 2.494,
        2.442, 3.227, 2.643,
        2.475, 2.922, 2.677,
        2.208, 3.170, 2.409],

      "weights_comment": "weights for second layer ((f2*f2*n1)*n2 dimensional) in other words each of n2 filters have a f2*f2*n1 cube of weights (each column for different filter, each row for different pixel in range 0 - f2*f2*n1, so each paragraph is cell, 9 cells total)",
      "weights": [
        1.000, 2.000, 1.001,
        2.001, 1.002, 2.002,
        1.010, 2.010, 1.011],

      "bias_comment": "biases for 2nd layer (n2 dimensional)",
      "bias": [0.1, 0.2, 0.3]
    }

  }

}
