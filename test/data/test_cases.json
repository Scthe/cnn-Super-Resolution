{
  "layer_1": {

    "n1_comment": "filter count for 1st layer",
    "n1": 3,

    "f1_comment": "spatial size",
    "f1": 3,

    "input_w": 5,
    "input_h": 5,
    "input": [
      0.0,     1.0,     0.81205, 0.85311, 0.43704,
      0.16959, 0.701,   0.413,   0.886,   0.78658,
      0.42971, 0.299,   0.587,   0.114,   0.70724,
      0.67016, 0.74524, 0.85311, 0.74524, 0.29913,
      0.8062,  0.58765, 0.8585,  0.5927,  0.70196],

    "weights_comment": "weights for 1st layer. (each column for different filter, each row for different pixel in range 0 - f1^2, so each paragraph is 1 row of pixels in f1=3)",
    "weights": [
      1.0, 0.0, 0.0,
      0.0, 1.0, 0.0,
      1.0, 0.0, 0.0,

      0.0, 1.0, 0.0,
      1.0, 0.0, 1.0,
      0.0, 1.0, 0.0,

      1.0, 0.0, 0.0,
      0.0, 1.0, 0.0,
      1.0, 0.0, 0.0
    ],

    "bias_comment": "biases for 1st layer",
    "bias": [0.1, 0.2, 0.3]
  },



  "layer_2": {

    "data_set_1": {
      "n2_comment": "filter count for 2nd layer",
      "n2": 2,

      "f2_comment": "spatial size",
      "f2": 3,

      "input": [
        0.406, 0.419, 0.598,
        0.442, 0.685, 0.528,
        0.627, 0.489, 0.642,
        0.376, 0.563, 0.499,
        0.680, 0.371, 0.571,
        0.390, 0.672, 0.453,
        0.626, 0.550, 0.609,
        0.386, 0.674, 0.634,
        0.666, 0.413, 0.609],

        "output": [0.169, -0.731],

        "weights_comment": "weights for second layer ((f2*f2*n1)*n2 dimensional) in other words each of n2 filters have a f2*f2*n1 cube of weights (each column for different filter, each row for different pixel in range 0 - f2*f2*n1, so each paragraph is cell, 9 cells total)",
        "weights": [
          -0.369,  0.025,
           0.213,  0.058,
           0.410, -0.068,

           0.236,  0.071,
          -0.429, -0.104,
           0.161,  0.087,

           0.361, -0.055,
           0.273,  0.071,
           0.431, -0.095,


           0.229,  0.378,
          -0.178,  0.343,
           0.114, -0.409,

          -0.220, -0.364,
           0.711,	 0.281,
           0.851,	-1.001,

          -0.411,	 0.661,
          -0.831,	-0.091,
           0.281,	-0.341,


          -0.931,	 0.511,
           0.141,	-0.591,
           0.491,	-0.921,

           0.291,	-0.211,
           0.151,	 0.491,
          -0.431,	-0.321,

          -0.631,	 0.301,
          -0.001,	-0.761,
          -0.021,	 0.501],

        "bias_comment": "biases for 2nd layer (n2 dimensional)",
        "bias": [0.1, 0.2]
    },

    "data_set_2": {
      "n2_comment": "filter count for 2nd layer",
      "n2": 3,

      "f2_comment": "spatial size",
      "f2": 1,

      "input": [
        0.406, 0.419, 0.598,
        0.442, 0.685, 0.528,
        0.627, 0.489, 0.642,
        0.376, 0.563, 0.499,
        0.680, 0.371, 0.571,
        0.390, 0.672, 0.453,
        0.626, 0.550, 0.609,
        0.386, 0.674, 0.634,
        0.666, 0.413, 0.609],

      "output": [
        0.369, 0.025, 0.229,
        0.213, 0.058, 0.378,
        0.410, -0.068, 0.178,
        0.236, 0.071, 0.343,
        0.429, -0.104, 0.114,
        0.161, 0.087, 0.409,
        0.361, -0.055, 0.220,
        0.273, 0.071, 0.364,
        0.431, -0.095, 0.132],

      "weights_comment": "weights for second layer ((f2*f2*n1)*n2 dimensional) in other words each of n2 filters have a f2*f2*n1 cube of weights (each column for different filter, each row for different pixel in range 0 - f2*f2*n1, so each paragraph is cell, 9 cells total)",
      "weights": [
         0.20, -0.45, -0.35,
        -0.45,  0.16,  0.54,
         0.63, -0.10, -0.26],

      "bias_comment": "biases for 2nd layer (n2 dimensional)",
      "bias": [0.1, 0.2, 0.3]
    }

  }

}
